import yagmail
from weasyprint import HTML
import os
from datetime import datetime
import smtplib # NEW: Import smtplib for direct email sending
from email.message import EmailMessage # NEW: Import EmailMessage

# Get email credentials from environment variables
EMAIL_USER = os.getenv("EMAIL_USER")
EMAIL_PASS = os.getenv("EMAIL_PASS") # This is likely an app password for Gmail
SMTP_SERVER = os.getenv("SMTP_SERVER", "smtp.gmail.com") # Default for Gmail
SMTP_PORT = int(os.getenv("SMTP_PORT", 587)) # Default for Gmail TLS

# 🔧 NEW: Configure frontend URL from environment variable
FRONTEND_URL = os.getenv("FRONTEND_URL", "https://coldemailai.in")  # Production URL

# Import _RESET_TOKEN_EXPIRE_MINUTES from auth.services for the email content
# NOTE: This is a bit of a hacky import. In a larger app, you'd have a shared config.
try:
    from app.auth.services import _RESET_TOKEN_EXPIRE_MINUTES
except ImportError:
    _RESET_TOKEN_EXPIRE_MINUTES = 30 # Fallback if import fails

def generate_html_report(data, user_email=None, period="Full Period"):
    matched = data["matched"]
    unmatched_ledger = data["unmatched_ledger"]
    unmatched_bank = data["unmatched_bank"]

    html = f"""
    <html>
    <head><style>
      body {{ font-family: Arial; padding: 20px; }}
      h1 {{ color: #2a7ae2; }}
      table {{ width: 100%; border-collapse: collapse; margin-top: 20px; }}
      th, td {{ border: 1px solid #ccc; padding: 8px; font-size: 14px; }}
      th {{ background-color: #f3f3f3; }}
      .summary {{ background: #f9f9f9; padding: 10px; border-left: 4px solid #2a7ae2; margin-top: 20px; }}
    </style></head>
    <body>
      <h1>ReconBot Reconciliation Summary</h1>
      <div class="summary">
        <p><strong>Generated for:</strong> {user_email or 'N/A'}</p>
        <p><strong>Report Period:</strong> {period}</p>
        <p><strong>Generated At:</strong> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
        <p><strong>Matched:</strong> {len(matched)}</p>
        <p><strong>Unmatched in Ledger:</strong> {len(unmatched_ledger)}</p>
        <p><strong>Unmatched in Bank:</strong> {len(unmatched_bank)}</p>
      </div>
    """

    # Matched Transactions Table
    html += """
    <h2>Matched Transactions</h2>
    <table><tr><th>Ledger Ref</th><th>Bank Ref</th><th>Date</th><th>Amount</th><th>Similarity</th></tr>
    """
    for row in matched[:10]:  # Limit for email body
        html += f"<tr><td>{row.get('ledger_ref')}</td><td>{row.get('bank_ref')}</td><td>{row.get('ledger_date')}</td><td>{row.get('amount')}</td><td>{row.get('similarity', 'N/A')}</td></tr>"
    html += "</table>"

    # Unmatched Ledger
    html += """
    <h2>Unmatched Ledger Entries</h2>
    <table><tr><th>Date</th><th>Amount</th><th>Narration</th></tr>
    """
    for row in unmatched_ledger[:10]:
        html += f"<tr><td>{row['date']}</td><td>{row['amount']}</td><td>{row['narration']}</td></tr>"
    html += "</table>"

    # Unmatched Bank
    html += """
    <h2>Unmatched Bank Entries</h2>
    <table><tr><th>Date</th><th>Amount</th><th>Narration</th></tr>
    """
    for row in unmatched_bank[:10]:
        html += f"<tr><td>{row['date']}</td><td>{row['amount']}</td><td>{row['narration']}</td></tr>"
    html += "</table>"

    html += "<p style='margin-top:30px;color:#888'>Generated by ReconBot 🧠</p></body></html>"
    return html

def send_email_report(to_email, summary_data, filename="recon_report.pdf"):
    html = generate_html_report(summary_data, to_email, "July 2025")

    # ✅ Force correct .pdf and validate file size
    if not filename.endswith(".pdf"):
        filename += ".pdf"
    HTML(string=html).write_pdf(filename)

    if not os.path.exists(filename) or os.path.getsize(filename) < 1000:
        raise Exception(f"❌ PDF generation failed or file too small: {filename}")

    yag = yagmail.SMTP(EMAIL_USER, EMAIL_PASS) # Use direct env vars
    yag.send(
        to=to_email,
        subject="🤖 ReconBot Monthly Reconciliation Report",  # Fixed encoding
        contents="Please find the attached reconciliation summary.",
        attachments=filename
    )

# 🔧 FIXED: Function to send password reset emails with production URL
async def send_password_reset_email(to_email: str, token: str):
    """Sends a password reset email using smtplib with production URL."""
    if not EMAIL_USER or not EMAIL_PASS:
        print("Email sending skipped: EMAIL_USER or EMAIL_PASS not set.")
        return

    # 🔧 Build reset link using FRONTEND_URL environment variable
    reset_link = f"{FRONTEND_URL}/reset-password?token={token}"

    msg = EmailMessage()
    msg['Subject'] = "ReconBot: Password Reset Request"  # Fixed encoding
    msg['From'] = EMAIL_USER
    msg['To'] = to_email
    msg.set_content(f"""Hello,

You have requested a password reset for your ReconBot account.
Please click on the link below to reset your password:

{reset_link}

This link will expire in {_RESET_TOKEN_EXPIRE_MINUTES} minutes.

If you did not request a password reset, please ignore this email.

Best regards,
ReconBot Team""")

    try:
        # Use smtplib for sending
        with smtplib.SMTP(SMTP_SERVER, SMTP_PORT) as smtp:
            smtp.starttls() # Enable TLS
            smtp.login(EMAIL_USER, EMAIL_PASS)
            smtp.send_message(msg)
        print(f"Password reset email sent to {to_email}")
    except Exception as e:
        print(f"Failed to send password reset email to {to_email}: {e}")