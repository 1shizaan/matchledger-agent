# import yagmail
# from weasyprint import HTML
# import os
# from datetime import datetime
# import smtplib # NEW: Import smtplib for direct email sending
# from email.message import EmailMessage # NEW: Import EmailMessage
# from datetime import datetime

# # Get email credentials from environment variables
# EMAIL_USER = os.getenv("EMAIL_USER")
# EMAIL_PASS = os.getenv("EMAIL_PASS") # This is likely an app password for Gmail
# SMTP_SERVER = os.getenv("SMTP_SERVER", "smtp.gmail.com") # Default for Gmail
# SMTP_PORT = int(os.getenv("SMTP_PORT", 587)) # Default for Gmail TLS

# # üîß NEW: Configure frontend URL from environment variable
# FRONTEND_URL = os.getenv("FRONTEND_URL", "https://coldemailai.in")  # Production URL

# # Import _RESET_TOKEN_EXPIRE_MINUTES from auth.services for the email content
# # NOTE: This is a bit of a hacky import. In a larger app, you'd have a shared config.
# try:
#     from app.auth.services import _RESET_TOKEN_EXPIRE_MINUTES
# except ImportError:
#     _RESET_TOKEN_EXPIRE_MINUTES = 30 # Fallback if import fails

# def generate_html_report(data, user_email=None, period="Full Period"):
#     matched = data["matched"]
#     unmatched_ledger = data["unmatched_ledger"]
#     unmatched_bank = data["unmatched_bank"]

#     html = f"""
#     <html>
#     <head><style>
#       body {{ font-family: Arial; padding: 20px; }}
#       h1 {{ color: #2a7ae2; }}
#       table {{ width: 100%; border-collapse: collapse; margin-top: 20px; }}
#       th, td {{ border: 1px solid #ccc; padding: 8px; font-size: 14px; text-align: left; }}
#       th {{ background-color: #f3f3f3; }}
#       .summary {{ background: #f9f9f9; padding: 10px; border-left: 4px solid #2a7ae2; margin-top: 20px; }}
#     </style></head>
#     <body>
#       <h1>ReconBot Reconciliation Summary</h1>
#       <div class="summary">
#         <p><strong>Generated for:</strong> {user_email or 'N/A'}</p>
#         <p><strong>Report Period:</strong> {period}</p>
#         <p><strong>Generated At:</strong> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
#         <p><strong>Matched:</strong> {len(matched)}</p>
#         <p><strong>Unmatched in Ledger:</strong> {len(unmatched_ledger)}</p>
#         <p><strong>Unmatched in Bank:</strong> {len(unmatched_bank)}</p>
#       </div>
#     """

#     # Matched Transactions Table
#     html += """
#     <h2>Matched Transactions</h2>
#     <table><tr><th>Ledger Ref</th><th>Bank Ref</th><th>Date</th><th>Amount</th><th>Similarity</th></tr>
#     """
#     # ‚úÖ CORRECTED LOOP: Accesses the nested 'ledger' and 'bank' dictionaries
#     for row in matched[:10]:
#         ledger = row.get('ledger', {})
#         bank = row.get('bank', {})
#         similarity = f"{row.get('similarity_score', 0) * 100:.0f}%"
        
#         html += f"""
#         <tr>
#             <td>{ledger.get('ref_no', 'N/A')}</td>
#             <td>{bank.get('ref_no', 'N/A')}</td>
#             <td>{ledger.get('date', 'N/A')}</td>
#             <td>${ledger.get('amount', 0):,.2f}</td>
#             <td>{similarity}</td>
#         </tr>
#         """
#     html += "</table>"

#     # Unmatched Ledger (This part was already correct)
#     html += """
#     <h2>Unmatched Ledger Entries</h2>
#     <table><tr><th>Date</th><th>Amount</th><th>Narration</th></tr>
#     """
#     for row in unmatched_ledger[:10]:
#         html += f"<tr><td>{row['date']}</td><td>{row['amount']}</td><td>{row['narration']}</td></tr>"
#     html += "</table>"

#     # Unmatched Bank (This part was also correct)
#     html += """
#     <h2>Unmatched Bank Entries</h2>
#     <table><tr><th>Date</th><th>Amount</th><th>Narration</th></tr>
#     """
#     for row in unmatched_bank[:10]:
#         html += f"<tr><td>{row['date']}</td><td>{row['amount']}</td><td>{row['narration']}</td></tr>"
#     html += "</table>"

#     html += "<p style='margin-top:30px;color:#888'>Generated by MatchLedger AI üß†</p></body></html>"
#     return html
# def send_email_report(to_email, summary_data, filename="recon_report.pdf"):
#     current_period = datetime.now().strftime("%B %Y")
#     html = generate_html_report(summary_data, to_email, current_period)

#     # ‚úÖ Force correct .pdf and validate file size
#     if not filename.endswith(".pdf"):
#         filename += ".pdf"
#     HTML(string=html).write_pdf(filename)

#     if not os.path.exists(filename) or os.path.getsize(filename) < 1000:
#         raise Exception(f"‚ùå PDF generation failed or file too small: {filename}")

#     yag = yagmail.SMTP(EMAIL_USER, EMAIL_PASS) # Use direct env vars
#     yag.send(
#         to=to_email,
#         subject=" ReconBot Monthly Reconciliation Report",  # Fixed encoding
#         contents="Please find the attached reconciliation summary.",
#         attachments=filename
#     )

# # üîß FIXED: Function to send password reset emails with production URL
# async def send_password_reset_email(to_email: str, token: str):
#     """Sends a password reset email using smtplib with production URL."""
#     if not EMAIL_USER or not EMAIL_PASS:
#         print("Email sending skipped: EMAIL_USER or EMAIL_PASS not set.")
#         return

#     # üîß Build reset link using FRONTEND_URL environment variable
#     reset_link = f"{FRONTEND_URL}/reset-password?token={token}"

#     msg = EmailMessage()
#     msg['Subject'] = "ReconBot: Password Reset Request"  # Fixed encoding
#     msg['From'] = EMAIL_USER
#     msg['To'] = to_email
#     msg.set_content(f"""Hello,

# You have requested a password reset for your ReconBot account.
# Please click on the link below to reset your password:

# {reset_link}

# This link will expire in {_RESET_TOKEN_EXPIRE_MINUTES} minutes.

# If you did not request a password reset, please ignore this email.

# Best regards,
# ReconBot Team""")

#     try:
#         # Use smtplib for sending
#         with smtplib.SMTP(SMTP_SERVER, SMTP_PORT) as smtp:
#             smtp.starttls() # Enable TLS
#             smtp.login(EMAIL_USER, EMAIL_PASS)
#             smtp.send_message(msg)
#         print(f"Password reset email sent to {to_email}")
#     except Exception as e:
#         print(f"Failed to send password reset email to {to_email}: {e}")

import os
import yagmail
import smtplib
from email.message import EmailMessage
from weasyprint import HTML
from datetime import datetime
import base64
from cryptography.fernet import Fernet
import hashlib

# --- ENV CONFIG - Fixed to match your .env file ---
EMAIL_USER = os.getenv("EMAIL_USER") or os.getenv("SMTP_USER")  # Fallback to SMTP_USER
EMAIL_PASS = os.getenv("EMAIL_PASS") or os.getenv("SMTP_PASSWORD")  # Fallback to SMTP_PASSWORD
SMTP_SERVER = os.getenv("SMTP_SERVER") or os.getenv("SMTP_HOST", "smtp.zoho.in")  # Fallback to SMTP_HOST
SMTP_PORT = int(os.getenv("SMTP_PORT", 587))
FRONTEND_URL = os.getenv("FRONTEND_URL", "https://matchledger.in")
EMAILS_FROM_NAME = os.getenv("EMAILS_FROM_NAME", "MatchLedger Support")

# Security for token encryption
RESET_PASSWORD_SECRET_KEY = os.getenv("RESET_PASSWORD_SECRET_KEY")

# Reset token expiry (import fallback)
try:
    from app.auth.services import _RESET_TOKEN_EXPIRE_MINUTES
except ImportError:
    _RESET_TOKEN_EXPIRE_MINUTES = 60

# --- Token Security Functions ---
def _get_encryption_key():
    """Generate a consistent encryption key from the secret key"""
    if not RESET_PASSWORD_SECRET_KEY:
        raise ValueError("RESET_PASSWORD_SECRET_KEY not configured")

    # Create a 32-byte key from the secret key
    key_material = hashlib.sha256(RESET_PASSWORD_SECRET_KEY.encode()).digest()
    return base64.urlsafe_b64encode(key_material)

def encrypt_token(token: str) -> str:
    """Encrypt a token for secure URL transmission"""
    try:
        key = _get_encryption_key()
        fernet = Fernet(key)
        encrypted_token = fernet.encrypt(token.encode())
        # URL-safe base64 encoding
        return base64.urlsafe_b64encode(encrypted_token).decode()
    except Exception as e:
        print(f"‚ö†Ô∏è Token encryption failed: {e}")
        # Fallback: return a hash instead of the raw token
        return hashlib.sha256(token.encode()).hexdigest()[:16]

def decrypt_token(encrypted_token: str) -> str:
    """Decrypt a token from URL parameter"""
    try:
        key = _get_encryption_key()
        fernet = Fernet(key)
        decoded_token = base64.urlsafe_b64decode(encrypted_token.encode())
        return fernet.decrypt(decoded_token).decode()
    except Exception as e:
        print(f"‚ö†Ô∏è Token decryption failed: {e}")
        return None

# --- HTML Report Generator ---
def generate_html_report(data, user_email=None, period="Full Period"):
    matched = data["matched"]
    unmatched_ledger = data["unmatched_ledger"]
    unmatched_bank = data["unmatched_bank"]

    html = f"""
    <html>
    <head><style>
      body {{ font-family: Arial; padding: 20px; }}
      h1 {{ color: #2a7ae2; }}
      table {{ width: 100%; border-collapse: collapse; margin-top: 20px; }}
      th, td {{ border: 1px solid #ccc; padding: 8px; font-size: 14px; text-align: left; }}
      th {{ background-color: #f3f3f3; }}
      .summary {{ background: #f9f9f9; padding: 10px; border-left: 4px solid #2a7ae2; margin-top: 20px; }}
    </style></head>
    <body>
      <h1>MatchLedger Reconciliation Summary</h1>
      <div class="summary">
        <p><strong>Generated for:</strong> {user_email or 'N/A'}</p>
        <p><strong>Report Period:</strong> {period}</p>
        <p><strong>Generated At:</strong> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
        <p><strong>Matched:</strong> {len(matched)}</p>
        <p><strong>Unmatched in Ledger:</strong> {len(unmatched_ledger)}</p>
        <p><strong>Unmatched in Bank:</strong> {len(unmatched_bank)}</p>
      </div>
    """

    # Matched Transactions
    html += "<h2>Matched Transactions</h2><table><tr><th>Ledger Ref</th><th>Bank Ref</th><th>Date</th><th>Amount</th><th>Similarity</th></tr>"
    for row in matched[:10]:
        ledger = row.get('ledger', {})
        bank = row.get('bank', {})
        similarity = f"{row.get('similarity_score', 0) * 100:.0f}%"
        html += f"<tr><td>{ledger.get('ref_no', 'N/A')}</td><td>{bank.get('ref_no', 'N/A')}</td><td>{ledger.get('date', 'N/A')}</td><td>${ledger.get('amount', 0):,.2f}</td><td>{similarity}</td></tr>"
    html += "</table>"

    # Unmatched Ledger
    html += "<h2>Unmatched Ledger Entries</h2><table><tr><th>Date</th><th>Amount</th><th>Narration</th></tr>"
    for row in unmatched_ledger[:10]:
        html += f"<tr><td>{row['date']}</td><td>{row['amount']}</td><td>{row['narration']}</td></tr>"
    html += "</table>"

    # Unmatched Bank
    html += "<h2>Unmatched Bank Entries</h2><table><tr><th>Date</th><th>Amount</th><th>Narration</th></tr>"
    for row in unmatched_bank[:10]:
        html += f"<tr><td>{row['date']}</td><td>{row['amount']}</td><td>{row['narration']}</td></tr>"
    html += "</table>"

    html += "<p style='margin-top:30px;color:#888'>Generated by MatchLedger AI üß†</p></body></html>"
    return html

# --- PDF + Email Sending - Fixed ---
def send_email_report(to_email, summary_data, filename="recon_report.pdf"):
    # Check if email is configured
    if not EMAIL_USER or not EMAIL_PASS:
        print("‚ö†Ô∏è Email credentials not configured, skipping email sending")
        print(f"EMAIL_USER: {EMAIL_USER}")
        print(f"EMAIL_PASS: {'***' if EMAIL_PASS else 'None'}")
        return

    period = datetime.now().strftime("%B %Y")
    html = generate_html_report(summary_data, to_email, period)
    temp_pdf_path = os.path.join("/tmp", filename)

    # Generate PDF
    try:
        HTML(string=html).write_pdf(temp_pdf_path)
        print(f"‚úÖ PDF generated: {temp_pdf_path}")
    except Exception as e:
        raise Exception(f"‚ùå PDF generation failed: {e}")

    if not os.path.exists(temp_pdf_path) or os.path.getsize(temp_pdf_path) < 1000:
        raise Exception("‚ùå Generated PDF is missing or too small.")

    # Send via yagmail (Zoho SMTP) - Fixed with explicit parameters
    try:
        print(f"üìß Attempting to send email to {to_email}")
        print(f"SMTP Config: {EMAIL_USER}@{SMTP_SERVER}:{SMTP_PORT}")

        # Create yagmail SMTP object with explicit parameters
        yag = yagmail.SMTP(
            user=EMAIL_USER,
            password=EMAIL_PASS,
            host=SMTP_SERVER,
            port=SMTP_PORT,
            smtp_starttls=True,
            smtp_ssl=False
        )

        yag.send(
            to=to_email,
            subject="MatchLedger Reconciliation Report",
            contents=[
                "Hi there!",
                "",
                "Please find your reconciliation report attached.",
                "",
                "Best regards,",
                "MatchLedger Team"
            ],
            attachments=temp_pdf_path
        )
        print(f"‚úÖ Email sent successfully to {to_email}")

    except Exception as e:
        print(f"‚ùå Email sending failed: {e}")
        raise Exception(f"‚ùå Email sending failed: {e}")
    finally:
        # Clean up PDF file
        try:
            if os.path.exists(temp_pdf_path):
                os.remove(temp_pdf_path)
                print(f"üóëÔ∏è Cleaned up temp file: {temp_pdf_path}")
        except Exception as cleanup_error:
            print(f"‚ö†Ô∏è Failed to clean up temp file: {cleanup_error}")

# --- Password Reset via smtplib - With Secure Token ---
async def send_password_reset_email(to_email: str, token: str):
    if not EMAIL_USER or not EMAIL_PASS:
        print("Email config missing, skipping reset email.")
        return

    # Encrypt the token for secure URL transmission
    try:
        encrypted_token = encrypt_token(token)
        reset_link = f"{FRONTEND_URL}/reset-password?t={encrypted_token}"
        print(f"üîê Token encrypted for secure transmission")
    except Exception as e:
        print(f"‚ö†Ô∏è Token encryption failed, using fallback: {e}")
        # Fallback: use a short hash instead of raw token
        token_hash = hashlib.sha256(f"{token}:{RESET_PASSWORD_SECRET_KEY}".encode()).hexdigest()[:24]
        reset_link = f"{FRONTEND_URL}/reset-password?t={token_hash}"

    msg = EmailMessage()
    msg["Subject"] = "MatchLedger: Password Reset Request"
    msg["From"] = f"{EMAILS_FROM_NAME} <{EMAIL_USER}>"
    msg["To"] = to_email
    msg.set_content(f"""Hello,

You requested a password reset for your MatchLedger account.

Reset your password using the secure link below (valid for {_RESET_TOKEN_EXPIRE_MINUTES} minutes):

{reset_link}

‚ö†Ô∏è This link will expire automatically for your security.

If you didn't request this, please ignore this email and your account will remain secure.

Best regards,
MatchLedger Support Team

---
This is an automated email. Please do not reply to this message.
""")

    try:
        with smtplib.SMTP(SMTP_SERVER, SMTP_PORT) as smtp:
            smtp.starttls()
            smtp.login(EMAIL_USER, EMAIL_PASS)
            smtp.send_message(msg)
        print(f"‚úÖ Secure password reset email sent to {to_email}")
    except Exception as e:
        print(f"‚ùå Failed to send password reset email to {to_email}: {e}")
        raise Exception(f"‚ùå Password reset email failed: {e}")
    
#23-08-25